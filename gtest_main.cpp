#include <cstring>
#include "gtest-1.13/googletest/include/gtest/gtest.h"
#include "parse.hpp"

std::vector<uint8_t> kIn{
	0xAA, 0x43, 0x47, 0x50, 0x2F, 0x30, 0x31, 0xF8, 0x00, 0x02, 0x00, 0x00, 0x00, 0x84, 0x00, 0xA8,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x05, 0x00, 0x01, 0x02, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x5F, 0x9A, 0xB2, 0x56, 0x65, 0x3D, 0x11, 0x08,
		0x50, 0x6A, 0xE8, 0x2D, 0x5F, 0x63, 0x8F, 0x74, 0x00, 0x0E, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0xB8, 0x0B, 0x00, 0x00, 0xB8, 0x0B, 0x00, 0x00, 0x12, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x05, 0xA4, 0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x01, 0x00, 0x00, 0x16, 0x43, 0x69, 0x74, 0x72, 0x69,
		0x78, 0x2E, 0x54, 0x63, 0x70, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
		0x65
};

TEST(Parse, shrb_check_arg) {
	char const* script{"exec(shrb{9});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "arg \"shrb\" must be < 8: 9", parse.msg.size()));
}

TEST(Parse, shrb) {
	char const* script{"exec(shrb{3});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	std::vector<uint8_t> out{
		0x50, 0x2F, 0x30, 0x31, 0xF8, 0x00, 0x02, 0x00, 0x00, 0x00, 0x84, 0x00, 0xA8,
			0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x05, 0x00, 0x01, 0x02, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x5F, 0x9A, 0xB2, 0x56, 0x65, 0x3D, 0x11, 0x08,
			0x50, 0x6A, 0xE8, 0x2D, 0x5F, 0x63, 0x8F, 0x74, 0x00, 0x0E, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
			0xB8, 0x0B, 0x00, 0x00, 0xB8, 0x0B, 0x00, 0x00, 0x12, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x05, 0xA4, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x01, 0x00, 0x00, 0x16, 0x43, 0x69, 0x74, 0x72, 0x69,
			0x78, 0x2E, 0x54, 0x63, 0x70, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
			0x65
	};
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(out.data(), vec.data(), out.size()));
}

TEST(Parse, shr) {
	char const* script{"exec(shr{3});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	std::vector<uint8_t> out{
		0x50, 0x2F, 0x30, 0x31, 0xF8, 0x00, 0x02, 0x00, 0x00, 0x00, 0x84, 0x00, 0xA8,
			0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x05, 0x00, 0x01, 0x02, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x5F, 0x9A, 0xB2, 0x56, 0x65, 0x3D, 0x11, 0x08,
			0x50, 0x6A, 0xE8, 0x2D, 0x5F, 0x63, 0x8F, 0x74, 0x00, 0x0E, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
			0xB8, 0x0B, 0x00, 0x00, 0xB8, 0x0B, 0x00, 0x00, 0x12, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x05, 0xA4, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x01, 0x00, 0x00, 0x16, 0x43, 0x69, 0x74, 0x72, 0x69,
			0x78, 0x2E, 0x54, 0x63, 0x70, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
			0x65
	};
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(out.data(), vec.data(), out.size()));
}

TEST(Parse, shr_insert) {
	char const* script{"exec(shr{3},insert{[1,2,3]});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	std::vector<uint8_t> out{
		1,2,3,0x50, 0x2F, 0x30, 0x31, 0xF8, 0x00, 0x02, 0x00, 0x00, 0x00, 0x84, 0x00, 0xA8,
			0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x05, 0x00, 0x01, 0x02, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x5F, 0x9A, 0xB2, 0x56, 0x65, 0x3D, 0x11, 0x08,
			0x50, 0x6A, 0xE8, 0x2D, 0x5F, 0x63, 0x8F, 0x74, 0x00, 0x0E, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
			0xB8, 0x0B, 0x00, 0x00, 0xB8, 0x0B, 0x00, 0x00, 0x12, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x05, 0xA4, 0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x01, 0x1C, 0x01, 0x00, 0x01, 0x00, 0x00, 0x16, 0x43, 0x69, 0x74, 0x72, 0x69,
			0x78, 0x2E, 0x54, 0x63, 0x70, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
			0x65
	};
	parse.RunInsert(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(out.data(), vec.data(), out.size()));
}

TEST(Parse, out_of_range_left) {
	char const* script{"exec(shr{3},crop{1,1},shl{1});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "Out of range: -1", parse.msg.size()));
}

TEST(Parse, out_of_range_right) {
	char const* script{"exec(shr{140});"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "Out of range: -11", parse.msg.size()));
}

TEST(Parse, missing_bracket) {
	char const* script{"exec(shr{140};"};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "Missing \")\"", parse.msg.size()));
}

TEST(Parse, check_lid_and) {
	char const* script{"exec("
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			"and{0b10},"
			");"
	};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	ASSERT_TRUE(parse.lid == 0xFFFFFFFFFFFFFFFF);
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "LID overflow", parse.msg.size()));
}

TEST(Parse, check_lid_and_not) {
	char const* script{"exec("
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			"!and{0b1},"
			");"
	};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	ASSERT_FALSE(parse.msg.size() == 0);
	ASSERT_TRUE(parse.lid == 0xFFFFFFFFFFFFFFFF);
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "LID overflow", parse.msg.size()));
}

TEST(Parse, check_lid_split) {
	char const* script{"exec("
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			"split{0b10},"
			");"
	};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	ASSERT_FALSE(parse.msg.size() == 0);
	ASSERT_TRUE(parse.lid == 0x0202020202020202);
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "LID overflow", parse.msg.size()));
}

TEST(Parse, check_lid_split_not) {
	char const* script{"exec("
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			"!split{0b10},"
			");"
	};
	std::vector<uint8_t> vec{};
	uint8_t err{};
	uint64_t num_pck{};
	auto parse = Parsed(script, vec, err, num_pck);
	parse.Run(kIn.data(), kIn.size());
	ASSERT_FALSE(parse.msg.size() == 0);
	ASSERT_TRUE(parse.lid == 0xfdfdfdfdfdfdfdfd);
	EXPECT_TRUE(0 == std::memcmp(parse.msg.c_str(), "LID overflow", parse.msg.size()));
}

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
